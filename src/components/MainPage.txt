

<template>
  <div class="task-container">
    <transition name="fade">
      <div v-if="notificationMessage" :class="['notification', notificationType]">
        {{ notificationMessage }}
      </div>
    </transition>

    <div class="header">
      <h1 class="title">{{ msg }}</h1>
      <div class="stats">
        <div class="stat-item">
          <span class="stat-number">{{ completedTasks.length }}</span>
          <span class="stat-label">–í—ã–ø–æ–ª–Ω–µ–Ω–æ</span>
        </div>
        <div class="stat-item">
          <span class="stat-number">{{ pendingTasks.length }}</span>
          <span class="stat-label">–û—Å—Ç–∞–ª–æ—Å—å</span>
        </div>
      </div>
    </div>

    <div class="sync-section">
      <div class="sync-controls">
        <button
          @click="refreshTasks"
          class="refresh-button"
          :disabled="isRefreshing"
          :class="{ 'refreshing': isRefreshing }"
        >
          <span class="refresh-icon" :class="{ 'spinning': isRefreshing }">üîÑ</span>
          <span class="button-text">
            {{ isRefreshing ? '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ...' : '–û–±–Ω–æ–≤–∏—Ç—å' }}
          </span>
        </button>

        <div class="auto-sync-toggle">
          <button
            @click="toggleAutoSync"
            class="sync-toggle-button"
            :class="{ 'active': autoSyncEnabled }"
          >
            <span class="sync-icon">{{ autoSyncEnabled ? 'üîí' : 'üîì' }}</span>
            <span class="button-text">
              {{ autoSyncEnabled ? '–ê–≤—Ç–æ-—Å–∏–Ω—Ö –í–ö–õ' : '–ê–≤—Ç–æ-—Å–∏–Ω—Ö –í–´–ö–õ' }}
            </span>
          </button>
          <div v-if="autoSyncEnabled" class="sync-status">
            <span class="sync-indicator" :class="{ 'active': syncIndicator }"></span>
            <span class="next-sync-text">
              –°–ª–µ–¥—É—é—â–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {{ nextSyncCountdown }}—Å
            </span>
          </div>
        </div>
      </div>

      <div class="last-updated" v-if="lastUpdated">
        <span class="update-text">
          –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {{ formatLastUpdated() }}
        </span>
      </div>
    </div>

    <div class="input-section">
      <div class="input-group">
        <input
          v-model="newTask"
          placeholder="–ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞"
          class="task-input"
          @keyup.enter="addTask"
          :class="{ 'shake': inputError }"
          :disabled="isAddingTask"
        />
        <select
          v-model="newTaskDifficulty"
          class="difficulty-select"
          :disabled="isAddingTask"
        >
          <option value="easy">–õ–µ–≥–∫–æ</option>
          <option value="normal">–ù–æ—Ä–º–∞–ª—å–Ω–æ</option>
          <option value="hard">–°–ª–æ–∂–Ω–æ</option>
        </select>
        <button
          @click="addTask"
          class="add-button"
          :disabled="!newTask.trim() || isAddingTask"
        >
          <span v-if="!isAddingTask" class="button-content">
            <span class="button-text">–î–æ–±–∞–≤–∏—Ç—å</span>
            <span class="button-icon">+</span>
          </span>
          <span v-else class="loading-content">
            <span class="spinner"></span>
            <span class="button-text">–î–æ–±–∞–≤–ª–µ–Ω–∏–µ...</span>
          </span>
        </button>
      </div>
    </div>

    <div class="filter-section">
      <div class="filter-buttons">
        <button
          @click="currentFilter = 'all'"
          :class="{ active: currentFilter === 'all' }"
          class="filter-btn"
        >
          –í—Å–µ ({{ tasks.length }})
        </button>
        <button
          @click="currentFilter = 'pending'"
          :class="{ active: currentFilter === 'pending' }"
          class="filter-btn"
        >
          –ê–∫—Ç–∏–≤–Ω—ã–µ ({{ pendingTasks.length }})
        </button>
        <button
          @click="currentFilter = 'completed'"
          :class="{ active: currentFilter === 'completed' }"
          class="filter-btn"
        >
          –í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ ({{ completedTasks.length }})
        </button>
      </div>
    </div>

    <div class="tasks-section">
      <transition-group name="task-list" tag="ul" class="task-list">
        <li
          v-for="task in filteredTasks"
          :key="task.id"
          class="task-item"
          :class="{
            'deleting': task.deleting,
            'completed': task.completed,
            'updating': task.updating
          }"
        >
          <div class="task-content">
            <div class="task-left">
              <button
                @click="toggleTask(task.id)"
                class="checkbox-button"
                :disabled="task.updating"
              >
                <span class="checkbox" :class="{ checked: task.completed }">
                  <span v-if="task.completed" class="checkmark">‚úì</span>
                </span>
              </button>
              <div class="task-info">
                <span class="task-text" :class="{ completed: task.completed }">
                  {{ task.text }}
                </span>
                <div class="task-meta">
                  <span class="difficulty-badge" :class="task.difficulty">
                    {{ getDifficultyLabel(task.difficulty) }}
                  </span>
                  <span class="task-date">
                    {{ formatDate(task.createdAt) }}
                  </span>
                </div>
              </div>
            </div>
            <div class="task-actions">
              <span v-if="task.updating" class="updating-spinner"></span>
              <button
                @click="deleteTask(task.id)"
                class="delete-button"
                :disabled="task.deleting || task.updating"
              >
                <span class="delete-icon">√ó</span>
              </button>
            </div>
          </div>
        </li>
      </transition-group>

      <div v-if="filteredTasks.length === 0" class="empty-state">
        <div class="empty-icon">
          {{ currentFilter === 'completed' ? 'üéâ' : currentFilter === 'pending' ? 'üìù' : 'üìã' }}
        </div>
        <p class="empty-text">
          {{ getEmptyStateText() }}
        </p>
      </div>
    </div>

    <ConfirmationModal
      :isVisible="showDeleteAccountModal"
      title="–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —É–¥–∞–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞"
      message="–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –±–µ–∑–≤–æ–∑–≤—Ä–∞—Ç–Ω–æ —É–¥–∞–ª–∏—Ç –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç –∏ –≤—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–∏–º –∑–∞–¥–∞—á–∏. –í—ã —É–≤–µ—Ä–µ–Ω—ã?"
      confirmButtonText="–£–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç"
      cancelButtonText="–û—Ç–º–µ–Ω–∞"
      :isLoading="isDeletingAccount"
      :inputErrorMessage="deletePasswordError"
      @confirm="confirmAccountDeletion"
      @cancel="cancelDeleteAccount"
    >
      <template v-slot:content v-if="!isDeletingAccount">
        <div class="modal-input-group">
          <label for="currentLoginPassword">–í–∞—à —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å:</label>
          <input type="password" id="currentLoginPassword" v-model="currentLoginPassword" autocomplete="current-password" />
        </div>
      </template>
    </ConfirmationModal>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch, defineExpose } from 'vue'; // Removed defineEmits import from here
import { db, auth, deleteUser, signOut as firebaseSignOut } from '../firebase';
import {
  collection,
  getDocs,
  deleteDoc,
  doc,
  updateDoc,
  query,
  where,
  orderBy,
  getDoc,
  setDoc,
  addDoc
} from 'firebase/firestore';
import { reauthenticateWithCredential, EmailAuthProvider } from 'firebase/auth';
import { useRouter } from 'vue-router';
import ConfirmationModal from './ConfirmationModal.vue';

// defineEmits is a compiler macro, no need to import it explicitly
const emit = defineEmits(['show-reauth-modal']); // defineEmits can be declared directly here

const router = useRouter();

// --- Props ---
const props = defineProps({
  msg: {
    type: String,
    default: "–ú–µ–Ω–µ–¥–∂–µ—Ä –∑–∞–¥–∞—á"
  },
  user: {
    type: Object,
    default: null
  }
});

// --- Reactive State ---
const newTask = ref('');
const newTaskDifficulty = ref('normal');
const tasks = ref([]);
const inputError = ref(false);
const isAddingTask = ref(false);
const currentFilter = ref('all');

// Sync and Refresh state
const isRefreshing = ref(false);
const autoSyncEnabled = ref(true);
const syncIndicator = ref(false);
const lastUpdated = ref(null);
const nextSyncCountdown = ref(0);
const currentTime = ref(Date.now());

// Intervals for polling and countdown
let autoSyncIntervalId = null;
let countdownIntervalId = null;
let updateCurrentTimeIntervalId = null;

const SYNC_INTERVAL = 10000;

// Account Deletion State
const showDeleteAccountModal = ref(false);
const currentLoginPassword = ref('');
const isDeletingAccount = ref(false);
const deletePasswordError = ref(''); // Error message for password input

// Notification State
const notificationMessage = ref('');
const notificationType = ref('');
let notificationTimeoutId = null;


// --- Computed Properties ---
const completedTasks = computed(() => {
  return tasks.value.filter(task => task.completed);
});

const pendingTasks = computed(() => {
  return tasks.value.filter(task => !task.completed);
});

const filteredTasks = computed(() => {
  switch (currentFilter.value) {
    case 'completed':
      return completedTasks.value;
    case 'pending':
      return pendingTasks.value;
    default:
      // Sort tasks by creation date (newest first) for consistency
      return [...tasks.value].sort((a, b) => {
        // Ensure both a.createdAt and b.createdAt are valid Date objects or Firebase Timestamps
        const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
        const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
        return dateB.getTime() - dateA.getTime();
      });
  }
});

// --- Methods ---

/**
 * Displays a notification message.
 */


/**
 * Loads user preferences from Firestore.
 */
const loadUserPreferences = async (userId) => {
  if (!userId) {
    console.log("No userId provided to loadUserPreferences. Skipping preference load.");
    return;
  }

  try {
    const docRef = doc(db, "userPreferences", userId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      const preferences = docSnap.data();
      if (typeof preferences.autoSyncEnabled === 'boolean') {
        autoSyncEnabled.value = preferences.autoSyncEnabled;
        console.log("Loaded autoSyncEnabled from Firestore:", preferences.autoSyncEnabled);
      }
    } else {
      console.log("No user preferences found for this user. Will use default autoSyncEnabled: true.");
    }
  } catch (e) {
    console.error("Error loading user preferences:", e);
  }
};

/**
 * Saves a single user preference to Firestore.
 */
const saveUserPreference = async (key, value) => {
  if (!props.user || !props.user.uid) {
    console.error("Cannot save user preference: User not authenticated or UID unavailable.");
    return;
  }

  try {
    const docRef = doc(db, "userPreferences", props.user.uid);
    await setDoc(docRef, { [key]: value }, { merge: true });
    console.log(`User preference '${key}' saved as '${value}' to Firestore.`);
  } catch (e) {
    console.error(`Error saving user preference '${key}':`, e);
  }
};


/**
 * Loads tasks from Firestore. This method performs a single fetch.
 * It's used for initial load, manual refresh, and by the auto-sync polling.
 */
const loadTasks = async (userId) => {
  if (!userId) {
    tasks.value = [];
    console.log("Cannot load tasks: No user ID provided (user logged out or not initialized).");
    return;
  }

  isRefreshing.value = true;
  syncIndicator.value = true;

  try {
    const q = query(collection(db, "tasks"), where("userId", "==", userId), orderBy("createdAt", "desc"));
    const querySnapshot = await getDocs(q);

    tasks.value = querySnapshot.docs.map(doc => ({
      id: doc.id,
      deleting: false,
      updating: false,
      completed: doc.data().completed ?? false,
      difficulty: doc.data().difficulty ?? "normal",
      createdAt: doc.data().createdAt,
      text: doc.data().text
    }));

    lastUpdated.value = new Date();
  } catch (e) {
    console.error("Error loading tasks:", e);
  } finally {
    setTimeout(() => {
      syncIndicator.value = false;
      isRefreshing.value = false;
    }, 500);
  }
};

/**
 * Initiates a manual refresh of tasks.
 * Resets the auto-sync timer if auto-sync is enabled.
 */
const refreshTasks = async () => {
  if (!props.user || !props.user.uid || isRefreshing.value) {
    console.log("Refresh aborted: User not authenticated or already refreshing.");
    return;
  }

  if (autoSyncEnabled.value) {
    stopAutoSync();
    await loadTasks(props.user.uid);
    startAutoSync();
  } else {
    await loadTasks(props.user.uid);
  }
};

/**
 * Toggles the auto-sync feature.
 */
const toggleAutoSync = () => {
  autoSyncEnabled.value = !autoSyncEnabled.value;
  saveUserPreference('autoSyncEnabled', autoSyncEnabled.value);

  if (autoSyncEnabled.value) {
    startAutoSync();
  } else {
    stopAutoSync();
  }
};

/**
 * Starts the auto-sync by setting up the polling interval and countdown timer.
 */
const startAutoSync = () => {
  if (!props.user || !props.user.uid) {
    console.log("Cannot start auto-sync: User not authenticated or UID unavailable.");
    return;
  }

  stopAutoSync();

  loadTasks(props.user.uid);

  autoSyncIntervalId = setInterval(async () => {
    console.log('Auto-sync: Refreshing tasks...');
    if (props.user && props.user.uid) {
      await loadTasks(props.user.uid);
      nextSyncCountdown.value = SYNC_INTERVAL / 1000;
    } else {
      console.log("Auto-sync interval detected user logged out. Stopping auto-sync.");
      stopAutoSync();
    }
  }, SYNC_INTERVAL);
  nextSyncCountdown.value = SYNC_INTERVAL / 1000;
  countdownIntervalId = setInterval(() => {
    if (nextSyncCountdown.value > 0) {
      nextSyncCountdown.value--;
    }
  }, 1000);
  console.log("Auto-sync enabled (polling every 10 seconds).");
};

/**
 * Stops the auto-sync by clearing all intervals.
 */
const stopAutoSync = () => {
  if (autoSyncIntervalId) {
    clearInterval(autoSyncIntervalId);
    autoSyncIntervalId = null;
  }
  if (countdownIntervalId) {
    clearInterval(countdownIntervalId);
    countdownIntervalId = null;
  }
  nextSyncCountdown.value = 0;
  console.log("Auto-sync disabled.");
};

const addTask = async () => {
  if (!newTask.value.trim()) {
    inputError.value = true;
    setTimeout(() => {
      inputError.value = false;
    }, 500);
    return;
  }
  if (!props.user || !props.user.uid) {
    console.error("User not authenticated to add task.");
    showNotification("–í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á.", "error");
    return;
  }

  isAddingTask.value = true;

  try {
    await new Promise(resolve => setTimeout(resolve, 500));

    const taskData = {
      text: newTask.value.trim(),
      completed: false,
      difficulty: newTaskDifficulty.value,
      createdAt: new Date(),
      userId: props.user.uid
    };

    const docRef = await addDoc(collection(db, "tasks"), taskData);

    tasks.value.unshift({
      id: docRef.id,
      deleting: false,
      updating: false,
      ...taskData
    });

    newTask.value = "";
    newTaskDifficulty.value = "normal";
    showNotification("–ó–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞!", "success");
  } catch (e) {
    console.error("Error adding task:", e);
    showNotification("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏.", "error");
  } finally {
    isAddingTask.value = false;
  }
};

const toggleTask = async (id) => {
  const task = tasks.value.find(t => t.id === id);
  if (!task || !props.user || !props.user.uid) {
    console.error("Cannot toggle task: Task not found or user not authenticated.");
    return;
  }

  const originalCompleted = task.completed;
  task.updating = true;
  task.completed = !task.completed;

  try {
    await new Promise(resolve => setTimeout(resolve, 300));

    await updateDoc(doc(db, "tasks", id), {
      completed: task.completed
    });
    showNotification("–ó–∞–¥–∞—á–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!", "success");
  } catch (e) {
    console.error("Error updating task:", e);
    task.completed = originalCompleted;
    showNotification("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏.", "error");
  } finally {
    task.updating = false;
  }
};

const deleteTask = async (id) => {
  const taskIndex = tasks.value.findIndex(t => t.id === id);
  if (taskIndex === -1 || !props.user || !props.user.uid) {
    console.error("Cannot delete task: Task not found or user not authenticated.");
    return;
  }

  const taskToDelete = tasks.value[taskIndex];
  taskToDelete.deleting = true;

  try {
    await new Promise(resolve => setTimeout(resolve, 300));
    await deleteDoc(doc(db, "tasks", id));

    tasks.value = tasks.value.filter(t => t.id !== id);
    showNotification("–ó–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!", "success");
  } catch (e) {
    console.error("Error deleting task:", e);
    if (taskToDelete) {
      taskToDelete.deleting = false;
    }
    showNotification("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏.", "error");
  }
};

const getDifficultyLabel = (difficulty) => {
  const labels = {
    easy: "–õ–µ–≥–∫–æ",
    normal: "–ù–æ—Ä–º–∞–ª—å–Ω–æ",
    hard: "–°–ª–æ–∂–Ω–æ"
  };
  return labels[difficulty] || labels.normal;
};

const formatDate = (timestamp) => {
  if (!timestamp) return "";
  let date;
  if (timestamp.toDate && typeof timestamp.toDate === 'function') {
    date = timestamp.toDate();
  } else if (timestamp instanceof Date) {
    date = timestamp;
  } else {
    date = new Date(timestamp);
  }

  if (isNaN(date.getTime())) {
    return "–ù–µ–≤–µ—Ä–Ω–∞—è –¥–∞—Ç–∞";
  }

  return date.toLocaleDateString('ru-RU', {
    day: '2-digit',
    month: '2-digit',
    year: '2-digit'
  });
};

const formatLastUpdated = () => {
  if (!lastUpdated.value) return '';

  const now = new Date(currentTime.value);
  const diffSeconds = Math.floor((now.getTime() - lastUpdated.value.getTime()) / 1000);

  if (diffSeconds < 60) {
    if (diffSeconds <= 5) {
      return '—Ç–æ–ª—å–∫–æ —á—Ç–æ';
    } else {
      return `${diffSeconds} —Å–µ–∫. –Ω–∞–∑–∞–¥`;
    }
  } else if (diffSeconds < 3600) {
    const minutes = Math.floor(diffSeconds / 60);
    return `${minutes} –º–∏–Ω. –Ω–∞–∑–∞–¥`;
  } else if (diffSeconds < 86400) {
    const hours = Math.floor(diffSeconds / 3600);
    return `${hours} —á–∞—Å. –Ω–∞–∑–∞–¥`;
  } else {
    return lastUpdated.value.toLocaleDateString('ru-RU', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  }
};

const getEmptyStateText = () => {
  switch (currentFilter.value) {
    case 'completed':
      return '–ù–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á';
    case 'pending':
      return '–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á. –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!';
    default:
      return '–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á. –î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–≤—É—é!';
  }
};

/**
 * Opens the account deletion confirmation modal specific to MainPage.vue.
 */
const promptDeleteAccount = () => {
  if (!props.user) {
    showNotification("–í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.", "error");
    return;
  }
  // Clear previous inputs and errors when opening the modal
  currentLoginPassword.value = '';
  deletePasswordError.value = '';
  isDeletingAccount.value = false; // Ensure loading state is off when opening
  showDeleteAccountModal.value = true;
};

/**
 * Handles the actual account deletion process (Client-Side).
 */
const confirmAccountDeletion = async () => {
  const currentUser = auth.currentUser;
  deletePasswordError.value = ''; // Clear previous password error before new attempt

  if (!currentUser || !currentUser.email) {
    // This case should ideally not happen if promptDeleteAccount checks auth
    showNotification("–û—à–∏–±–∫–∞: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –∏–ª–∏ Email –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.", "error");
    // Don't close modal, let user see error or cancel manually
    return;
  }
  if (!currentLoginPassword.value.trim()) {
    deletePasswordError.value = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –ø–∞—Ä–æ–ª—å."; // More generic initial error
    return; // Keep modal open and show specific error
  }

  isDeletingAccount.value = true; // Set loading state to true immediately for deletion logic

  try {
    // 1. Client-side re-authentication (REQUIRED by Firebase Auth for deleteUser)
    console.log("Attempting client-side re-authentication...");
    const credential = EmailAuthProvider.credential(currentUser.email, currentLoginPassword.value);
    await reauthenticateWithCredential(currentUser, credential);
    console.log("Client-side re-authentication successful.");
    showNotification("–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø—Ä–æ–π–¥–µ–Ω–∞. –£–¥–∞–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞...", "success", 1500);

    // 2. Delete all tasks associated with the user (client-side)
    console.log(`Attempting to delete tasks for user: ${currentUser.uid}`);
    const tasksRef = collection(db, 'tasks');
    const userTasksQuery = query(tasksRef, where('userId', '==', currentUser.uid));
    const querySnapshot = await getDocs(userTasksQuery);

    const deletePromises = [];
    querySnapshot.forEach((d) => {
      deletePromises.push(deleteDoc(d.ref));
    });

    // Ensure all Firestore deletions complete
    await Promise.all(deletePromises);
    console.log(`Successfully deleted ${querySnapshot.size} tasks for user.`);
    showNotification("–í—Å–µ –∑–∞–¥–∞—á–∏ —É–¥–∞–ª–µ–Ω—ã.", "success", 1000);

    // 3. Delete user preferences (client-side) - Assuming preferences are stored by UID
    const userPrefRef = doc(db, 'userPreferences', currentUser.uid);
    const userPrefSnap = await getDoc(userPrefRef);
    if (userPrefSnap.exists()) {
      await deleteDoc(userPrefRef);
      console.log(`Successfully deleted user preferences for user: ${currentUser.uid}`);
      showNotification("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–¥–∞–ª–µ–Ω—ã.", "success", 1000);
    }

    // 4. Delete the Firebase Authentication user account
    await deleteUser(currentUser);
    console.log("User account successfully deleted. Redirecting to /register.");
    showNotification("–ê–∫–∫–∞—É–Ω—Ç —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω. –í—ã –±—É–¥–µ—Ç–µ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω—ã.", "success", 3000);

    // Sign out to clear local state (though deleteUser often auto-logs out)
    await firebaseSignOut(auth);

    // Close the modal here because deletion was successful
    showDeleteAccountModal.value = false;
    currentLoginPassword.value = ''; // Clear password field on success

    // Redirect to login/register page after a short delay
    setTimeout(() => {
      router.replace('/register');
    }, 2500);

  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∞–∫–∫–∞—É–Ω—Ç–∞:", error);
    let notificationMessageText = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —É–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç.";

    if (error.code) {
        if (error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
            deletePasswordError.value = "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å."; // Specific error message for the modal input
            notificationMessageText = "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."; // More descriptive for global notification
        } else if (error.code === 'auth/user-not-found') {
            notificationMessageText = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω —É–∂–µ –±—ã–ª —É–¥–∞–ª–µ–Ω.";
        } else if (error.code === 'auth/requires-recent-login') {
            // This error means the user needs to re-authenticate more generally (e.g., if they were logged in for too long)
            // Emit to App.vue to show its generic re-auth modal (which then reloads the page or re-authenticates silently)
            emit('show-reauth-modal');
            // Do NOT set deletePasswordError or close modal here.
            // The re-auth modal will handle the re-authentication flow,
            // and upon success, the user can re-attempt deletion.
            return; // Exit this function, preventing further execution in finally block
        } else if (error.code === 'permission-denied') {
            notificationMessageText = `–û—à–∏–±–∫–∞: –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ Firestore. (${error.message})`;
        } else if (error.code === 'unavailable') {
            notificationMessageText = `–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –∏–ª–∏ —Å–ª—É–∂–±—ã Firebase –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.`;
        } else {
            notificationMessageText = `–û—à–∏–±–∫–∞ Firebase: ${error.message}`;
        }
    } else {
        notificationMessageText = `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: ${error.message || error}`;
    }
    showNotification(notificationMessageText, "error", 5000);

    // IMPORTANT: If there's a password error, the modal should remain open.
    // If it's another error (like network, or general firebase error), it might be okay to close or keep open.
    // For now, we'll keep it open if deletePasswordError is set.
    // If it's a general error not tied to input, it will remain open, which is acceptable.
  } finally {
    isDeletingAccount.value = false; // Always reset loading state
  }
};


// --- Watchers ---
// Watch the user prop for changes
watch(() => props.user, async (newVal, oldVal) => {
  if (newVal && newVal.uid) {
    console.log("MainPage: User prop changed to logged in:", newVal.uid);
    await loadUserPreferences(newVal.uid);
    if (autoSyncEnabled.value) {
      startAutoSync();
    } else {
      await loadTasks(newVal.uid);
    }
  } else if (oldVal && !newVal) {
    console.log("MainPage: User prop changed to logged out.");
    tasks.value = [];
    stopAutoSync();
  }
}, { immediate: true });

// --- Lifecycle Hooks ---
onMounted(() => {
  updateCurrentTimeIntervalId = setInterval(() => {
    currentTime.value = Date.now();
  }, 1000);
});

onUnmounted(() => {
  stopAutoSync();
  if (updateCurrentTimeIntervalId) {
    updateCurrentTimeIntervalId = null;
  }
});

// EXPOSE methods to parent components (App.vue)
defineExpose({
  promptDeleteAccount
});
</script>

<style scoped>
/* Your existing styles remain unchanged for most elements. */
.task-container {
  max-width: 700px;
  margin: 0 auto;
  padding: 2rem;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: calc(100vh - 70px);
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  box-sizing: border-box;
  border-radius: 15px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.header {
  text-align: center;
  margin-bottom: 2rem;
}

.title {
  color: white;
  font-size: 2.5rem;
  font-weight: 700;
  margin: 0 0 1rem 0;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  animation: fadeInDown 0.8s ease-out;
}

.stats {
  display: flex;
  justify-content: center;
  gap: 2rem;
  margin-top: 1rem;
}

.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  color: white;
  background: rgba(255, 255, 255, 0.1);
  padding: 1rem;
  border-radius: 12px;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.stat-number {
  font-size: 1.8rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
}

.stat-label {
  font-size: 0.9rem;
  opacity: 0.8;
}

/* --- New styles for sync section --- */
.sync-section {
  margin-bottom: 1.5rem;
  animation: fadeInUp 0.8s ease-out 0.1s both;
}

.sync-controls {
  display: flex;
  gap: 1rem;
  align-items: center;
  background: rgba(255, 255, 255, 0.15);
  padding: 1rem;
  border-radius: 12px;
  backdrop-filter: blur(10px);
  margin-bottom: 0.5rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.refresh-button {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: linear-gradient(45deg, #2196F3, #1976D2);
  color: white;
  border: none;
  padding: 0.8rem 1.2rem;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  min-width: 120px;
  justify-content: center;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.refresh-button:hover:not(:disabled) {
  background: linear-gradient(45deg, #1976D2, #2196F3);
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(33, 150, 243, 0.4);
}

.refresh-button:disabled {
  opacity: 0.7;
  cursor: not-allowed;
  background: #90CAF9;
  box-shadow: none;
}

.refresh-button.refreshing {
  background: linear-gradient(45deg, #FFB300, #F57C00);
  color: #fff;
}

.refresh-icon {
  font-size: 1.1rem;
  transition: transform 0.3s ease;
}

.refresh-icon.spinning {
  animation: spin 1s linear infinite;
}

.auto-sync-toggle {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex: 1;
}

.sync-toggle-button {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 2px solid rgba(255, 255, 255, 0.3);
  padding: 0.8rem 1.2rem;
  border-radius: 8px;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  min-width: 160px;
  justify-content: center;
}

.sync-toggle-button.active {
  background: linear-gradient(45deg, #4CAF50, #45a049);
  border-color: #4CAF50;
  box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
}

.sync-toggle-button:hover:not(.active) {
  background: rgba(255, 255, 255, 0.3);
}

.sync-toggle-button.active:hover {
  background: linear-gradient(45deg, #45a049, #4CAF50);
  box-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
}

.sync-icon {
  font-size: 1.1rem;
}

.sync-status {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: white;
  font-size: 0.8rem;
  margin-left: 0.5rem;
}

.sync-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.5);
  transition: all 0.3s ease;
}

.sync-indicator.active {
  background: #4CAF50;
  box-shadow: 0 0 10px rgba(76, 175, 80, 0.6);
  animation: pulse 1.5s infinite ease-in-out;
}

.next-sync-text {
  opacity: 0.8;
}

.last-updated {
  text-align: center;
  color: rgba(255, 255, 255, 0.8);
  font-size: 0.8rem;
  background: rgba(255, 255, 255, 0.05);
  padding: 0.5rem;
  border-radius: 8px;
  backdrop-filter: blur(5px);
  margin-top: 0.5rem;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.update-text {
  font-style: italic;
}
/* --- End of new styles for sync section --- */

.input-section {
  margin-bottom: 1.5rem;
  animation: fadeInUp 0.8s ease-out 0.2s both;
}

.input-group {
  display: flex;
  gap: 0.5rem;
  background: white;
  padding: 0.5rem;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  border: 1px solid rgba(0, 0, 0, 0.05);
}

.input-group:focus-within {
  transform: translateY(-2px);
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
}

.task-input {
  flex: 1;
  border: none;
  outline: none;
  font-size: 1.1rem;
  padding: 1rem;
  border-radius: 8px;
  background: transparent;
  transition: all 0.3s ease;
}

.difficulty-select {
  border: none;
  outline: none;
  font-size: 1rem;
  padding: 1rem;
  border-radius: 8px;
  background: #f8f9fa;
  cursor: pointer;
  min-width: 120px;
  border: 1px solid #e0e0e0;
}

.difficulty-select:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.task-input::placeholder {
  color: #999;
}

.task-input.shake {
  animation: shake 0.5s ease-in-out;
}

.add-button {
  background: linear-gradient(45deg, #4CAF50, #45a049);
  color: white;
  border: none;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  min-width: 140px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.button-content,
.loading-content {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  justify-content: center;
}

.add-button:hover:not(:disabled) {
  background: linear-gradient(45deg, #45a049, #4CAF50);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
}

.add-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  background: #A5D6A7;
  box-shadow: none;
}

.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top: 2px solid white;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.updating-spinner {
  width: 20px;
  height: 20px;
  border: 2px solid rgba(102, 126, 234, 0.3);
  border-top: 2px solid #667eea;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 0.5rem;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.15);
    opacity: 0.8;
  }
}

.filter-section {
  margin-bottom: 1.5rem;
  animation: fadeInUp 0.8s ease-out 0.3s both;
}

.filter-buttons {
  display: flex;
  gap: 0.5rem;
  background: rgba(255, 255, 255, 0.15);
  padding: 0.5rem;
  border-radius: 12px;
  backdrop-filter: blur(10px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.filter-btn {
  flex: 1;
  background: transparent;
  color: white;
  border: none;
  padding: 0.8rem 1rem;
  border-radius: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.3s ease;
  opacity: 0.7;
}

.filter-btn.active {
  background: white;
  color: #667eea;
  opacity: 1;
  font-weight: 600;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
}

.filter-btn:hover:not(.active) {
  opacity: 1;
  background: rgba(255, 255, 255, 0.1);
}

.tasks-section {
  animation: fadeInUp 0.8s ease-out 0.4s both;
}

.task-list {
  list-style: none;
  padding: 0;
  margin: 0;
  position: relative;
}

.task-item {
  background: white;
  margin-bottom: 1rem;
  border-radius: 12px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  overflow: hidden;
  border: 1px solid rgba(0, 0, 0, 0.05);
  will-change: transform, opacity;
}

.task-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.task-item.deleting {
  opacity: 0.6;
  transform: scale(0.95);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.task-item.completed {
  opacity: 0.8;
  background: #f0f0f0;
}

.task-item.updating {
  opacity: 0.7;
}

.task-content {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1.2rem;
}

.task-left {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex: 1;
}

.checkbox-button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 0;
}

.checkbox {
  width: 24px;
  height: 24px;
  border: 2px solid #ddd;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  flex-shrink: 0;
}

.checkbox.checked {
  background: #4CAF50;
  border-color: #4CAF50;
}

.checkmark {
  color: white;
  font-weight: bold;
  font-size: 14px;
}

.task-info {
  flex: 1;
}

.task-text {
  font-size: 1.1rem;
  color: #333;
  display: block;
  margin-bottom: 0.5rem;
  transition: all 0.3s ease;
  word-break: break-word;
}

.task-text.completed {
  text-decoration: line-through;
  color: #999;
}

.task-meta {
  display: flex;
  gap: 1rem;
  align-items: center;
  flex-wrap: wrap;
}

.difficulty-badge {
  padding: 0.2rem 0.6rem;
  border-radius: 12px;
  font-size: 0.8rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.difficulty-badge.easy {
  background: #d4edda;
  color: #155724;
}

.difficulty-badge.normal {
  background: #fff3cd;
  color: #856404;
}

.difficulty-badge.hard {
  background: #f8d7da;
  color: #721c24;
}

.task-date {
  font-size: 0.8rem;
  color: #999;
}

.task-actions {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-shrink: 0;
}

.delete-button {
  background: linear-gradient(45deg, #f44336, #d32f2f);
  color: white;
  border: none;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 1.5rem;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.delete-button:hover:not(:disabled) {
  background: linear-gradient(45deg, #d32f2f, #f44336);
  transform: scale(1.1);
  box-shadow: 0 4px 8px rgba(244, 67, 54, 0.3);
}

.delete-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  background: #FFCDD2;
  box-shadow: none;
}

.delete-icon {
  line-height: 1;
}

.empty-state {
  text-align: center;
  padding: 3rem 1rem;
  color: white;
  opacity: 0.8;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.empty-icon {
  font-size: 4rem;
  margin-bottom: 1rem;
  animation: bounce 2s infinite;
}

.empty-text {
  font-size: 1.2rem;
  margin: 0;
}

/* Animations */
@keyframes fadeInDown {
  from {
    opacity: 0;
    transform: translate3d(0, -100%, 0);
  }
  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translate3d(0, 100%, 0);
  }
  to {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}

@keyframes bounce {
  0%, 20%, 53%, 80%, 100% {
    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
    transform: translate3d(0,0,0);
  }
  40%, 43% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -30px, 0);
  }
  70% {
    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
    transform: translate3d(0, -15px, 0);
  }
  90% { transform: translate3d(0,-4px,0); }
}

/* ---- UNIFIED Transition group animations for filtering ---- */
.task-list-enter-active,
.task-list-leave-active {
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.task-list-enter-from {
  opacity: 0;
  transform: translateX(-30px) scale(0.9);
}

.task-list-leave-active {
  transition: opacity 0.3s ease, transform 0.3s ease;
  opacity: 1;
  position: absolute;
  width: 100%;
  top: 0;
  left: 0;
  right: 0;
  margin-bottom: 0 !important;
}

.task-list-leave-to {
  opacity: 0;
  transform: translateX(30px) scale(0.9);
}

/* For elements that are moving (due to other items being added/removed) */
.task-list-move {
  transition: transform 0.3s ease;
}

#currentLoginPassword {
  width: 100%;
  padding: 0.875rem 1.25rem;
  border: 2px solid transparent;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 500;
  color: #1f2937;
  background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
  box-shadow: 
    0 4px 6px rgba(0, 0, 0, 0.05),
    inset 0 1px 0 rgba(255, 255, 255, 0.9);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  outline: none;
  position: relative;
}

#currentLoginPassword::placeholder {
  color: #9ca3af;
  font-weight: 400;
}

#currentLoginPassword:focus {
  border-color: #667eea;
  background: linear-gradient(135deg, #ffffff 0%, #f0f4ff 100%);
  box-shadow: 
    0 8px 16px rgba(102, 126, 234, 0.15),
    0 0 0 4px rgba(102, 126, 234, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.9);
  transform: translateY(-1px);
}

#currentLoginPassword:hover:not(:focus) {
  border-color: rgba(102, 126, 234, 0.3);
  box-shadow: 
    0 6px 12px rgba(0, 0, 0, 0.08),
    inset 0 1px 0 rgba(255, 255, 255, 0.9);
}

/* Responsive design */
@media (max-width: 768px) {
  .task-container {
    padding: 1rem;
    min-height: calc(100vh - 50px);
  }

  .title {
    font-size: 2rem;
  }

  .stats {
    gap: 1rem;
    flex-wrap: wrap;
  }

  .stat-item {
    padding: 0.8rem;
    flex: 1 1 auto;
  }

  .stat-number {
    font-size: 1.5rem;
  }

  .sync-controls {
    flex-direction: column;
    gap: 0.8rem;
    padding: 0.8rem;
  }

  .refresh-button, .sync-toggle-button {
    width: 100%;
    min-width: unset;
  }

  .auto-sync-toggle {
    flex-direction: column;
    align-items: center;
    gap: 0.8rem;
    width: 100%;
  }

  .sync-status {
    width: 100%;
    justify-content: center;
    margin-left: 0;
  }

  .input-group {
    flex-direction: column;
    gap: 0.5rem;
  }

  .add-button {
    width: 100%;
    justify-content: center;
  }

  .filter-buttons {
    flex-direction: column;
    gap: 0.5rem;
  }

  .task-content {
    padding: 1rem;
    flex-direction: column;
    align-items: flex-start;
    gap: 1rem;
  }

  .task-left {
    width: 100%;
  }

  .task-info {
    width: calc(100% - 34px);
  }

  .task-text {
    font-size: 1rem;
  }

  .task-meta {
    flex-direction: row;
    align-items: center;
    gap: 0.8rem;
    margin-top: 0.5rem;
  }

  .task-actions {
    width: 100%;
    justify-content: flex-end;
    margin-top: 1rem;
  }

}
</style>
